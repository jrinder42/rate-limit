{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Limitor","text":"<p>This is a rate limiting library for Python that provides simple and efficient rate limiting mechanisms for your applications.  Whether you're building APIs, web services, or any other system that requires rate limiting, Limitor has got you covered.</p> Algorithm Design <p>All algorithms default to traffic shaping patterns as opposed to traffic policing.  This means that transmitted pieces of data are not dropped and we wait until the request can be completed barring a timeout.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple and intuitive API for defining rate limits</li> <li>Multiple rate limiting algorithms (Leaky Bucket, Token Bucket, etc.)</li> <li>Support for both synchronous and asynchronous operations</li> <li>Configurable burst handling</li> <li>Thread-safe implementations</li> </ul>"},{"location":"#bonus-features","title":"Bonus Features","text":"<ul> <li>Built-in support for LLM token rate limiting</li> <li>Easy integration with caching systems</li> <li>Add user-specific rate limits</li> </ul>"},{"location":"#example-usage","title":"Example Usage","text":"<p>LLM Token Rate Limiting</p> <ul> <li>System-wide rate limit of 100,000 tokens per second + simulate inputs of varying token amounts </li> </ul> decorator creation <p>This assumes all parameters need to be passed by the end-user. If you want to create a decorator with optional parameters, see <code>limitor/__init__.py</code> for an example.</p> SynchronousAsynchronous <pre><code>import random\nimport time\nfrom typing import Callable\n\nfrom limitor.base import SyncRateLimit\nfrom limitor.configs import BucketConfig\nfrom limitor.leaky_bucket.core import SyncLeakyBucket # (1)!\n\n\ndef rate_limit(capacity: int = 10, seconds: float = 1, bucket_cls: type[SyncRateLimit] = SyncLeakyBucket) -&gt; Callable:\n    bucket = bucket_cls(BucketConfig(capacity=capacity, seconds=seconds))\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            amount = kwargs.get(\"amount\", 1)\n            bucket.acquire(amount=amount)\n            return func(*args, **kwargs)\n        return wrapper\n\n    return decorator\n\n@rate_limit(capacity=100_000, seconds=1)\ndef process_request(amount=1):\n    print(f\"This is a rate-limited function: {time.strftime('%X')} - {amount} tokens\")\n\nfor _ in range(100):\n    # generate random prompt tokens between 5,000 and 30,000 for 100 sample requests\n    llm_prompt_tokens = random.randint(5_000, 30_000)\n    try:\n        process_request(amount=llm_prompt_tokens)\n    except Exception as error:\n        print(f\"Rate limit exceeded: {error}\")\n</code></pre> <ol> <li>You can use any of the following synchronous classes here:<ul> <li><code>SyncLeakyBucket</code></li> <li><code>SyncTokenBucket</code></li> <li><code>SyncVirtualSchedulingGCRA</code></li> <li><code>SyncLeakyBucketGCRA</code></li> </ul> </li> </ol> <pre><code>import random\nimport time\nimport asyncio\nfrom typing import Callable\n\nfrom limitor.base import AsyncRateLimit\nfrom limitor.configs import BucketConfig\nfrom limitor.leaky_bucket.core import AsyncLeakyBucket # (1)!\n\n\ndef rate_limit(capacity: int = 10, seconds: float = 1, bucket_cls: type[AsyncRateLimit] = AsyncLeakyBucket) -&gt; Callable:\n    bucket = bucket_cls(BucketConfig(capacity=capacity, seconds=seconds))\n\n    def decorator(func):\n        async def wrapper(*args, **kwargs):\n            amount = kwargs.get(\"amount\", 1)\n            await bucket.acquire(amount=amount)\n            return await func(*args, **kwargs)\n        return wrapper\n\n    return decorator\n\n@rate_limit(capacity=100_000, seconds=1)\nasync def process_request(amount=1):\n    print(f\"This is a rate-limited function: {time.strftime('%X')} - {amount} tokens\")\n\nasync def main():\n    for _ in range(100):\n        # generate random prompt tokens between 5,000 and 30,000 for 100 sample requests\n        llm_prompt_tokens = random.randint(5_000, 30_000)\n        try:\n            await process_request(amount=llm_prompt_tokens)\n        except Exception as error:\n            print(f\"Rate limit exceeded: {error}\")\n\nasyncio.run(main())\n</code></pre> <ol> <li>You can use any of the following asynchronous classes here:<ul> <li><code>AsyncLeakyBucket</code></li> <li><code>AsyncTokenBucket</code></li> <li><code>AsyncVirtualSchedulingGCRA</code></li> <li><code>AsyncLeakyBucketGCRA</code></li> </ul> </li> </ol>"},{"location":"#references","title":"References","text":"<ul> <li>Linear Programming<ul> <li>https://news.ycombinator.com/item?id=44393998</li> <li>https://vivekn.dev/blog/rate-limit-diophantine</li> </ul> </li> <li>Async Rate Limiting<ul> <li>https://asynciolimiter.readthedocs.io/en/latest/</li> </ul> </li> <li>Algorithms<ul> <li>Leaky Bucket<ul> <li>Benefits: Smooth, predictable traffic at a constant rate, discarding the overflow</li> </ul> </li> <li>Token Bucket<ul> <li>Benefits: Can be bursty with burst up to a limit, then at an average rate</li> </ul> </li> <li>Generic Cell Rate Algorithm<ul> <li>Benefits: More precise control over traffic shaping and policing</li> </ul> </li> </ul> </li> </ul>"},{"location":"generating_docs/","title":"Generating Docs","text":"<p>Enable GitHub Pages</p> <ol> <li> <p>On GitHub go to \u201cSettings\u201d -&gt; \u201cPages\u201d.</p> </li> <li> <p>In the \u201cSource\u201d section, choose \u201cDeploy from a branch\u201d in the dropdown menu.</p> </li> <li> <p>In the \u201cBranch\u201d section choose \u201cgh-pages\u201d and \u201c/root\u201d in the dropdown menus and click save.</p> </li> </ol> <p>You should now be able to verify the pages deployment in the Actions list.</p> <p>For full documentation visit mkdocs.org.</p>"},{"location":"generating_docs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"generating_docs/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/limitor/","title":"limitor","text":"<p>Main module for rate limiting functionality.</p>"},{"location":"reference/limitor/#limitor.async_rate_limit","title":"<code>async_rate_limit(_func=None, *, capacity=10, seconds=1, max_concurrent=None, bucket_cls=AsyncLeakyBucket)</code>","text":"<pre><code>async_rate_limit(\n    _func: None = None,\n    *,\n    capacity: float = 10,\n    seconds: float = 1,\n    max_concurrent: int | None = None,\n    bucket_cls: type[AsyncRateLimit] = AsyncLeakyBucket\n) -&gt; Callable[\n    [Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]\n]\n</code></pre><pre><code>async_rate_limit(\n    _func: Callable[P, Awaitable[R]],\n    *,\n    capacity: float = 10,\n    seconds: float = 1,\n    max_concurrent: int | None = None,\n    bucket_cls: type[AsyncRateLimit] = AsyncLeakyBucket\n) -&gt; Callable[P, Awaitable[R]]\n</code></pre> <p>Decorator to apply an asynchronous leaky bucket rate limit to a function.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>Callable[P, Awaitable[R]] | None</code> <p>Function to apply the rate limit to the function</p> <code>None</code> <code>capacity</code> <code>float</code> <p>Maximum number of requests allowed in the bucket, defaults to 10</p> <code>10</code> <code>seconds</code> <code>float</code> <p>Time period in seconds for the bucket to refill, defaults to 1</p> <code>1</code> <code>max_concurrent</code> <code>int | None</code> <p>Maximum number of concurrent requests allowed, defaults to None (no limit)</p> <code>None</code> <code>bucket_cls</code> <code>type[AsyncRateLimit]</code> <p>Bucket class, defaults to AsyncLeakyBucket</p> <code>AsyncLeakyBucket</code> <p>Returns:</p> Type Description <code>Callable[P, Awaitable[R]] | Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]</code> <p>A decorator that applies the rate limit to the function</p> Source code in <code>limitor/__init__.py</code> <pre><code>def async_rate_limit[**P, R](\n    _func: Callable[P, Awaitable[R]] | None = None,\n    *,\n    capacity: float = 10,\n    seconds: float = 1,\n    max_concurrent: int | None = None,\n    bucket_cls: type[AsyncRateLimit] = AsyncLeakyBucket,\n) -&gt; Callable[P, Awaitable[R]] | Callable[[Callable[P, Awaitable[R]]], Callable[P, Awaitable[R]]]:\n    \"\"\"Decorator to apply an asynchronous leaky bucket rate limit to a function.\n\n    Args:\n        _func: Function to apply the rate limit to the function\n        capacity: Maximum number of requests allowed in the bucket, defaults to 10\n        seconds: Time period in seconds for the bucket to refill, defaults to 1\n        max_concurrent: Maximum number of concurrent requests allowed, defaults to None (no limit)\n        bucket_cls: Bucket class, defaults to AsyncLeakyBucket\n\n    Returns:\n        A decorator that applies the rate limit to the function\n    \"\"\"\n    bucket = bucket_cls(BucketConfig(capacity=capacity, seconds=seconds), max_concurrent=max_concurrent)\n\n    def decorator(func: Callable[P, Awaitable[R]]) -&gt; Callable[P, Awaitable[R]]:\n        async def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            async with bucket:\n                return await func(*args, **kwargs)\n\n        return wrapper\n\n    if _func is None:\n        return decorator\n    return decorator(_func)\n</code></pre>"},{"location":"reference/limitor/#limitor.rate_limit","title":"<code>rate_limit(_func=None, *, capacity=10, seconds=1, bucket_cls=SyncLeakyBucket)</code>","text":"<pre><code>rate_limit(\n    _func: None = None,\n    *,\n    capacity: float = 10,\n    seconds: float = 1,\n    bucket_cls: type[SyncRateLimit] = SyncLeakyBucket\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre><pre><code>rate_limit(\n    _func: Callable[P, R],\n    *,\n    capacity: float = 10,\n    seconds: float = 1,\n    bucket_cls: type[SyncRateLimit] = SyncLeakyBucket\n) -&gt; Callable[P, R]\n</code></pre> <p>Decorator to apply a synchronous leaky bucket rate limit to a function.</p> <p>Parameters:</p> Name Type Description Default <code>_func</code> <code>Callable[P, R] | None</code> <p>Function to apply the rate limit to the function</p> <code>None</code> <code>capacity</code> <code>float</code> <p>Maximum number of requests allowed in the bucket, defaults to 10</p> <code>10</code> <code>seconds</code> <code>float</code> <p>Time period in seconds for the bucket to refill, defaults to 1</p> <code>1</code> <code>bucket_cls</code> <code>type[SyncRateLimit]</code> <p>Bucket class, defaults to SyncLeakyBucket</p> <code>SyncLeakyBucket</code> <p>Returns:</p> Type Description <code>Callable[P, R] | Callable[[Callable[P, R]], Callable[P, R]]</code> <p>A decorator that applies the rate limit to the function</p> Source code in <code>limitor/__init__.py</code> <pre><code>def rate_limit[**P, R](\n    _func: Callable[P, R] | None = None,\n    *,\n    capacity: float = 10,\n    seconds: float = 1,\n    bucket_cls: type[SyncRateLimit] = SyncLeakyBucket,\n) -&gt; Callable[P, R] | Callable[[Callable[P, R]], Callable[P, R]]:\n    \"\"\"Decorator to apply a synchronous leaky bucket rate limit to a function.\n\n    Args:\n        _func: Function to apply the rate limit to the function\n        capacity: Maximum number of requests allowed in the bucket, defaults to 10\n        seconds: Time period in seconds for the bucket to refill, defaults to 1\n        bucket_cls: Bucket class, defaults to SyncLeakyBucket\n\n    Returns:\n        A decorator that applies the rate limit to the function\n    \"\"\"\n    bucket = bucket_cls(BucketConfig(capacity=capacity, seconds=seconds))\n\n    def decorator(func: Callable[P, R]) -&gt; Callable[P, R]:\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n            with bucket:\n                return func(*args, **kwargs)\n\n        return wrapper\n\n    if _func is None:\n        return decorator\n    return decorator(_func)\n</code></pre>"},{"location":"reference/limitor/base/","title":"limitor.base","text":"<p>Rate Limit Protocols for Synchronous and Asynchronous Context Managers</p>"},{"location":"reference/limitor/base/#limitor.base.AsyncRateLimit","title":"<code>AsyncRateLimit</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Asynchronous Rate Limit Protocol</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BucketConfig</code> <p>Configuration for the rate limit</p> required <code>max_concurrent</code> <code>int | None</code> <p>Maximum number of concurrent requests allowed to acquire capacity</p> <code>None</code> Source code in <code>limitor/base.py</code> <pre><code>class AsyncRateLimit(Protocol):\n    \"\"\"Asynchronous Rate Limit Protocol\n\n    Args:\n        config: Configuration for the rate limit\n        max_concurrent: Maximum number of concurrent requests allowed to acquire capacity\n    \"\"\"\n\n    def __init__(self, config: BucketConfig, max_concurrent: int | None = None) -&gt; None: ...\n\n    async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n        \"\"\"Acquire an item from the rate limit. This method should block until a token is available\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n        \"\"\"\n\n    async def __aenter__(self) -&gt; AsyncRateLimit:\n        \"\"\"Enter the context manager, acquiring resources if necessary\n\n        This method should return an instance of AsyncRateLimit\n\n        Returns:\n            An instance of the rate limit context manager\n        \"\"\"\n\n    async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\n\n        Args:\n            exc_type: The type of the exception raised, if any\n            exc_val: The value of the exception raised, if any\n            exc_tb: The traceback object, if any\n        \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.AsyncRateLimit.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> <p>This method should return an instance of AsyncRateLimit</p> <p>Returns:</p> Type Description <code>AsyncRateLimit</code> <p>An instance of the rate limit context manager</p> Source code in <code>limitor/base.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncRateLimit:\n    \"\"\"Enter the context manager, acquiring resources if necessary\n\n    This method should return an instance of AsyncRateLimit\n\n    Returns:\n        An instance of the rate limit context manager\n    \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.AsyncRateLimit.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException]</code> <p>The type of the exception raised, if any</p> required <code>exc_val</code> <code>BaseException</code> <p>The value of the exception raised, if any</p> required <code>exc_tb</code> <code>TracebackType</code> <p>The traceback object, if any</p> required Source code in <code>limitor/base.py</code> <pre><code>async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\n\n    Args:\n        exc_type: The type of the exception raised, if any\n        exc_val: The value of the exception raised, if any\n        exc_tb: The traceback object, if any\n    \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.AsyncRateLimit.acquire","title":"<code>acquire(amount=1, timeout=None)</code>  <code>async</code>","text":"<p>Acquire an item from the rate limit. This method should block until a token is available</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>Optional timeout in seconds for the acquire operation</p> <code>None</code> Source code in <code>limitor/base.py</code> <pre><code>async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n    \"\"\"Acquire an item from the rate limit. This method should block until a token is available\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n        timeout: Optional timeout in seconds for the acquire operation\n    \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.HasCapacity","title":"<code>HasCapacity</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that have a capacity attribute</p> Source code in <code>limitor/base.py</code> <pre><code>class HasCapacity(Protocol):  # pylint: disable=too-few-public-methods\n    \"\"\"Protocol for objects that have a capacity attribute\"\"\"\n\n    capacity: float\n    \"\"\"Maximum number of items the bucket can hold i.e. number of requests that can be processed at once\"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.HasCapacity.capacity","title":"<code>capacity</code>  <code>instance-attribute</code>","text":"<p>Maximum number of items the bucket can hold i.e. number of requests that can be processed at once</p>"},{"location":"reference/limitor/base/#limitor.base.SyncRateLimit","title":"<code>SyncRateLimit</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Synchronous Rate Limit Protocol</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BucketConfig</code> <p>Configuration for the rate limit</p> required Source code in <code>limitor/base.py</code> <pre><code>class SyncRateLimit(Protocol):\n    \"\"\"Synchronous Rate Limit Protocol\n\n    Args:\n        config: Configuration for the rate limit\n    \"\"\"\n\n    def __init__(self, config: BucketConfig) -&gt; None: ...\n\n    def acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire an item from the rate limit. This method should block until a token is available\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n        \"\"\"\n\n    def __enter__(self) -&gt; SyncRateLimit:\n        \"\"\"Enter the context manager, acquiring resources if necessary\n\n        This method should return an instance of SyncRateLimit\n\n        Returns:\n            An instance of the rate limit context manager\n        \"\"\"\n\n    def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\n\n        Args:\n            exc_type: The type of the exception raised, if any\n            exc_val: The value of the exception raised, if any\n            exc_tb: The traceback object, if any\n        \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.SyncRateLimit.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> <p>This method should return an instance of SyncRateLimit</p> <p>Returns:</p> Type Description <code>SyncRateLimit</code> <p>An instance of the rate limit context manager</p> Source code in <code>limitor/base.py</code> <pre><code>def __enter__(self) -&gt; SyncRateLimit:\n    \"\"\"Enter the context manager, acquiring resources if necessary\n\n    This method should return an instance of SyncRateLimit\n\n    Returns:\n        An instance of the rate limit context manager\n    \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.SyncRateLimit.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException]</code> <p>The type of the exception raised, if any</p> required <code>exc_val</code> <code>BaseException</code> <p>The value of the exception raised, if any</p> required <code>exc_tb</code> <code>TracebackType</code> <p>The traceback object, if any</p> required Source code in <code>limitor/base.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\n\n    Args:\n        exc_type: The type of the exception raised, if any\n        exc_val: The value of the exception raised, if any\n        exc_tb: The traceback object, if any\n    \"\"\"\n</code></pre>"},{"location":"reference/limitor/base/#limitor.base.SyncRateLimit.acquire","title":"<code>acquire(amount=1)</code>","text":"<p>Acquire an item from the rate limit. This method should block until a token is available</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> Source code in <code>limitor/base.py</code> <pre><code>def acquire(self, amount: float = 1) -&gt; None:\n    \"\"\"Acquire an item from the rate limit. This method should block until a token is available\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n    \"\"\"\n</code></pre>"},{"location":"reference/limitor/configs/","title":"limitor.configs","text":"<p>Configuration for Rate Limiter implementations</p>"},{"location":"reference/limitor/configs/#limitor.configs.BucketConfig","title":"<code>BucketConfig</code>  <code>dataclass</code>","text":"<p>Configuration for any Rate Limiter</p> Source code in <code>limitor/configs.py</code> <pre><code>@dataclass\nclass BucketConfig:\n    \"\"\"Configuration for any Rate Limiter\"\"\"\n\n    capacity: float = 10\n    \"\"\"Maximum number of items the bucket can hold i.e. number of requests that can be processed at once\"\"\"\n\n    seconds: float = 1\n    \"\"\"Up to `capacity` acquisitions are allowed within this time period in a burst\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate the configuration parameters\"\"\"\n        if self.seconds &lt;= 0:\n            raise ValueError(\"seconds must be positive and non-zero\")\n\n        if self.capacity &lt; 1:\n            raise ValueError(\"capacity must be at least 1\")\n</code></pre>"},{"location":"reference/limitor/configs/#limitor.configs.BucketConfig.capacity","title":"<code>capacity = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of items the bucket can hold i.e. number of requests that can be processed at once</p>"},{"location":"reference/limitor/configs/#limitor.configs.BucketConfig.seconds","title":"<code>seconds = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Up to <code>capacity</code> acquisitions are allowed within this time period in a burst</p>"},{"location":"reference/limitor/configs/#limitor.configs.BucketConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate the configuration parameters</p> Source code in <code>limitor/configs.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate the configuration parameters\"\"\"\n    if self.seconds &lt;= 0:\n        raise ValueError(\"seconds must be positive and non-zero\")\n\n    if self.capacity &lt; 1:\n        raise ValueError(\"capacity must be at least 1\")\n</code></pre>"},{"location":"reference/limitor/configs/#limitor.configs.Capacity","title":"<code>Capacity</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Information about the current capacity of the bucket</p> Source code in <code>limitor/configs.py</code> <pre><code>class Capacity(NamedTuple):\n    \"\"\"Information about the current capacity of the bucket\"\"\"\n\n    has_capacity: bool\n    \"\"\"Indicates if the bucket has enough capacity to accommodate the requested amount\"\"\"\n\n    needed_capacity: float\n    \"\"\"Amount of capacity needed to accommodate the request, if any\"\"\"\n</code></pre>"},{"location":"reference/limitor/configs/#limitor.configs.Capacity.has_capacity","title":"<code>has_capacity</code>  <code>instance-attribute</code>","text":"<p>Indicates if the bucket has enough capacity to accommodate the requested amount</p>"},{"location":"reference/limitor/configs/#limitor.configs.Capacity.needed_capacity","title":"<code>needed_capacity</code>  <code>instance-attribute</code>","text":"<p>Amount of capacity needed to accommodate the request, if any</p>"},{"location":"reference/limitor/extra/","title":"limitor.extra","text":"<p>Extra rate limit implementations.</p>"},{"location":"reference/limitor/extra/leaky_bucket/","title":"limitor.extra.leaky_bucket","text":"<p>Extra leaky bucket rate limit implementations.</p>"},{"location":"reference/limitor/extra/leaky_bucket/core/","title":"limitor.extra.leaky_bucket.core","text":"<p>Async Leaky Bucket Rate Limiter (predictable, queue-based version)</p>"},{"location":"reference/limitor/extra/leaky_bucket/core/#limitor.extra.leaky_bucket.core.AsyncLeakyBucket","title":"<code>AsyncLeakyBucket</code>","text":"<p>Async Leaky Bucket Rate Limiter - Queue-based implementation</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the leaky bucket with the max capacity and time period in seconds</p> <code>None</code> Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> Source code in <code>limitor/extra/leaky_bucket/core.py</code> <pre><code>class AsyncLeakyBucket:\n    \"\"\"Async Leaky Bucket Rate Limiter - Queue-based implementation\n\n    Args:\n        bucket_config: Configuration for the leaky bucket with the max capacity and time period in seconds\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None = None):\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds\n        self._bucket_level = 0.0\n        self._last_leak = time.monotonic()\n        self._queue: asyncio.Queue[Any] = asyncio.Queue()\n        # Do NOT create background tasks at import/instantiation time because there\n        # may be no running event loop (e.g. when pytest constructs fixtures).\n        # Create the worker lazily on first use (inside an async context).\n        self._worker_task: asyncio.Task[None] | None = None\n\n    def _leak(self) -&gt; None:\n        \"\"\"Leak the bucket based on the elapsed time since the last leak\"\"\"\n        now = time.monotonic()\n        elapsed = now - self._last_leak\n        self._bucket_level = max(0.0, self._bucket_level - elapsed * self.leak_rate)\n        self._last_leak = now\n\n    def capacity_info(self, amount: float = 1) -&gt; Capacity:\n        \"\"\"Get the current capacity information of the leaky bucket\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Returns:\n            A named tuple indicating if the bucket has enough capacity and how much more is needed\n        \"\"\"\n        self._leak()\n        needed = self._bucket_level + amount - self.capacity\n        return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n\n    async def _worker(self) -&gt; None:  # single-worker coroutine\n        \"\"\"Worker coroutine that processes requests from the queue.\"\"\"\n        while True:\n            item = await self._queue.get()\n            if item is None:\n                self._queue.task_done()\n                break\n\n            amount, future, timeout = item\n            try:\n                await self._timeout_acquire(amount, timeout)\n                future.set_result(True)  # note: this can be set to anything\n            except Exception as error:  # pylint: disable=broad-exception-caught\n                future.set_exception(error)\n\n            self._queue.task_done()\n\n    async def _acquire_logic(self, amount: float) -&gt; None:\n        \"\"\"Core logic for acquiring capacity from the leaky bucket.\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Notes:\n            Adding a lock here ensures that the acquire logic is atomic, but it also means that the\n                requests are going to be done in the order they were received  i.e. not out-of-order like\n                most async programs.\n            The benefit is that with multiple concurrent requests, we can ensure that the bucket level\n                is updated correctly and that we don't have multiple requests trying to update the bucket level\n                at the same time, which could lead to an inconsistent state i.e. a race condition.\n        \"\"\"\n        capacity_info = self.capacity_info(amount=amount)\n        while not capacity_info.has_capacity:\n            needed = capacity_info.needed_capacity\n            # amount we need to wait to leak (either part or the entire capacity)\n            # needed is guaranteed to be positive here, so we can use it directly\n            wait_time = needed / self.leak_rate\n            if wait_time &gt; 0:\n                await asyncio.sleep(wait_time)\n\n            capacity_info = self.capacity_info(amount=amount)\n\n        self._bucket_level += amount\n\n    async def _timeout_acquire(self, amount: float, timeout: float | None) -&gt; None:\n        \"\"\"Acquire capacity from the leaky bucket, waiting asynchronously until allowed.\n\n        Supports timeout and cancellation.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n\n        Raises:\n            TimeoutError: If the acquire operation times out after the specified timeout period\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        if timeout is not None:\n            try:\n                await asyncio.wait_for(self._acquire_logic(amount), timeout=timeout)\n            except TimeoutError as error:\n                raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n        else:\n            await self._acquire_logic(amount)\n\n    async def acquire(self, amount: float = 1.0, timeout: float | None = None) -&gt; None:\n        \"\"\"Acquire capacity from the leaky bucket, waiting asynchronously until allowed.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n        \"\"\"\n        if self._worker_task is None or self._worker_task.done():\n            self._worker_task = asyncio.create_task(self._worker())\n\n        future = asyncio.get_event_loop().create_future()\n        await self._queue.put((amount, future, timeout))\n        await future\n\n    async def shutdown(self) -&gt; None:\n        \"\"\"Gracefully shut down the worker task.\"\"\"\n        if self._worker_task is None:  # if worker never started, do nothing\n            return\n\n        await self._queue.put(None)  # Sentinel value\n        await self._worker_task\n\n    async def __aenter__(self) -&gt; AsyncLeakyBucket:\n        \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n        await self.shutdown()\n        return None\n</code></pre>"},{"location":"reference/limitor/extra/leaky_bucket/core/#limitor.extra.leaky_bucket.core.AsyncLeakyBucket.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> Source code in <code>limitor/extra/leaky_bucket/core.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncLeakyBucket:\n    \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n    await self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/extra/leaky_bucket/core/#limitor.extra.leaky_bucket.core.AsyncLeakyBucket.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> Source code in <code>limitor/extra/leaky_bucket/core.py</code> <pre><code>async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n    await self.shutdown()\n    return None\n</code></pre>"},{"location":"reference/limitor/extra/leaky_bucket/core/#limitor.extra.leaky_bucket.core.AsyncLeakyBucket.acquire","title":"<code>acquire(amount=1.0, timeout=None)</code>  <code>async</code>","text":"<p>Acquire capacity from the leaky bucket, waiting asynchronously until allowed.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1.0</code> <code>timeout</code> <code>float | None</code> <p>Optional timeout in seconds for the acquire operation</p> <code>None</code> Source code in <code>limitor/extra/leaky_bucket/core.py</code> <pre><code>async def acquire(self, amount: float = 1.0, timeout: float | None = None) -&gt; None:\n    \"\"\"Acquire capacity from the leaky bucket, waiting asynchronously until allowed.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n        timeout: Optional timeout in seconds for the acquire operation\n    \"\"\"\n    if self._worker_task is None or self._worker_task.done():\n        self._worker_task = asyncio.create_task(self._worker())\n\n    future = asyncio.get_event_loop().create_future()\n    await self._queue.put((amount, future, timeout))\n    await future\n</code></pre>"},{"location":"reference/limitor/extra/leaky_bucket/core/#limitor.extra.leaky_bucket.core.AsyncLeakyBucket.capacity_info","title":"<code>capacity_info(amount=1)</code>","text":"<p>Get the current capacity information of the leaky bucket</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to check for, defaults to 1</p> <code>1</code> <p>Returns:</p> Type Description <code>Capacity</code> <p>A named tuple indicating if the bucket has enough capacity and how much more is needed</p> Source code in <code>limitor/extra/leaky_bucket/core.py</code> <pre><code>def capacity_info(self, amount: float = 1) -&gt; Capacity:\n    \"\"\"Get the current capacity information of the leaky bucket\n\n    Args:\n        amount: The amount of capacity to check for, defaults to 1\n\n    Returns:\n        A named tuple indicating if the bucket has enough capacity and how much more is needed\n    \"\"\"\n    self._leak()\n    needed = self._bucket_level + amount - self.capacity\n    return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n</code></pre>"},{"location":"reference/limitor/extra/leaky_bucket/core/#limitor.extra.leaky_bucket.core.AsyncLeakyBucket.shutdown","title":"<code>shutdown()</code>  <code>async</code>","text":"<p>Gracefully shut down the worker task.</p> Source code in <code>limitor/extra/leaky_bucket/core.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Gracefully shut down the worker task.\"\"\"\n    if self._worker_task is None:  # if worker never started, do nothing\n        return\n\n    await self._queue.put(None)  # Sentinel value\n    await self._worker_task\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/","title":"limitor.generic_cell_rate","text":"<p>Generic Cell Rate Algorithm Limiter</p>"},{"location":"reference/limitor/generic_cell_rate/core/","title":"limitor.generic_cell_rate.core","text":"<p>A simple synchronous implementation of the Generic Cell Rate Algorithm (GCRA)</p> <p>References: - https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm - https://en.wikipedia.org/wiki/Leaky_bucket</p>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncLeakyBucketGCRA","title":"<code>AsyncLeakyBucketGCRA</code>","text":"<p>Continuous-state Leaky Bucket Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the GCR algorithm with the max capacity and time period in seconds</p> required <code>max_concurrent</code> <code>int | None</code> <p>Maximum number of concurrent requests allowed to acquire capacity</p> <code>None</code> Note <p>This implementation is asynchronous and supports bursts up to the capacity within the specified time period</p> References <p>https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>class AsyncLeakyBucketGCRA:\n    \"\"\"Continuous-state Leaky Bucket Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the GCR algorithm with the max capacity and time period in seconds\n        max_concurrent: Maximum number of concurrent requests allowed to acquire capacity\n\n    Note:\n        This implementation is asynchronous and supports bursts up to the capacity within the specified time period\n\n    References:\n        https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None, max_concurrent: int | None = None):\n        # import config and set attributes\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds  # units per second\n        self.T = 1 / self.leak_rate  # time to leak one unit\n\n        # burst rate, but can't do this if the amount is variable\n        # self.tau = self.T * self.burst\n\n        self._bucket_level = 0.0  # current volume in the bucket\n        self._last_leak: float | None = None  # same as last conforming time or LCT\n\n        self.max_concurrent = max_concurrent\n        self._lock = asyncio.Lock()\n\n    async def _acquire_logic(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire resources, blocking if necessary to conform to the rate limit\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Notes:\n            Adding a lock here ensures that the acquire logic is atomic, but it also means that the\n                requests are going to be done in the order they were received  i.e. not out-of-order like\n                most async programs.\n            The benefit is that with multiple concurrent requests, we can ensure that the bucket level\n                is updated correctly and that we don't have multiple requests trying to update the bucket level\n                at the same time, which could lead to an inconsistent state i.e. a race condition.\n        \"\"\"\n        async with self._lock:  # ensure atomicity given we can have multiple concurrent requests\n            t_a = time.monotonic()\n            if self._last_leak is None:\n                # first cell\n                self._bucket_level = 0\n                self._last_leak = t_a\n\n            elapsed = t_a - self._last_leak\n            self._bucket_level = self._bucket_level - elapsed\n\n            # note: we can also make `self.capacity - amount` as class param = burst i.e. independent of capacity\n            tau = self.T * (self.capacity - amount)\n            if self._bucket_level &gt; tau:\n                delay = self._bucket_level - tau\n                await asyncio.sleep(delay)\n\n                self._bucket_level = self._bucket_level - delay\n                t_a += delay\n\n            self._bucket_level = max(0.0, self._bucket_level) + amount * self.T\n            self._last_leak = t_a\n\n    async def _semaphore_acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire capacity using a semaphore to limit concurrency.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n        \"\"\"\n        semaphore = asyncio.Semaphore(self.max_concurrent) if self.max_concurrent else nullcontext()\n        async with semaphore:\n            await self._acquire_logic(amount)\n\n    async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n        \"\"\"Acquire capacity, waiting asynchronously until allowed.\n\n        Supports timeout and cancellation.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n\n        Raises:\n            TimeoutError: If the acquire operation times out after the specified timeout period\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        if timeout is not None:\n            try:\n                await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n            except TimeoutError as error:\n                raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n        else:\n            await self._semaphore_acquire(amount)\n\n    async def __aenter__(self) -&gt; AsyncLeakyBucketGCRA:\n        \"\"\"Enter the context manager, acquiring resources if necessary\n\n        Returns:\n            An instance of the AsyncLeakyBucketGCRA class\n        \"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\n\n        Args:\n            exc_type: The type of the exception raised\n            exc_val: The value of the exception raised\n            exc_tb: The traceback object\n        \"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncLeakyBucketGCRA.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> <p>Returns:</p> Type Description <code>AsyncLeakyBucketGCRA</code> <p>An instance of the AsyncLeakyBucketGCRA class</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncLeakyBucketGCRA:\n    \"\"\"Enter the context manager, acquiring resources if necessary\n\n    Returns:\n        An instance of the AsyncLeakyBucketGCRA class\n    \"\"\"\n    await self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncLeakyBucketGCRA.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException]</code> <p>The type of the exception raised</p> required <code>exc_val</code> <code>BaseException</code> <p>The value of the exception raised</p> required <code>exc_tb</code> <code>TracebackType</code> <p>The traceback object</p> required Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\n\n    Args:\n        exc_type: The type of the exception raised\n        exc_val: The value of the exception raised\n        exc_tb: The traceback object\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncLeakyBucketGCRA.acquire","title":"<code>acquire(amount=1, timeout=None)</code>  <code>async</code>","text":"<p>Acquire capacity, waiting asynchronously until allowed.</p> <p>Supports timeout and cancellation.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>Optional timeout in seconds for the acquire operation</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the acquire operation times out after the specified timeout period</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n    \"\"\"Acquire capacity, waiting asynchronously until allowed.\n\n    Supports timeout and cancellation.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n        timeout: Optional timeout in seconds for the acquire operation\n\n    Raises:\n        TimeoutError: If the acquire operation times out after the specified timeout period\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    if timeout is not None:\n        try:\n            await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n        except TimeoutError as error:\n            raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n    else:\n        await self._semaphore_acquire(amount)\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncVirtualSchedulingGCRA","title":"<code>AsyncVirtualSchedulingGCRA</code>","text":"<p>Virtual Scheduling Generic Cell Rate Algorithm Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the GCR algorithm with the max capacity and time period in seconds</p> required <code>max_concurrent</code> <code>int | None</code> <p>Maximum number of concurrent requests allowed to acquire capacity</p> <code>None</code> Note <p>This implementation is asynchronous and supports bursts up to the capacity within the specified time period</p> References <p>https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>class AsyncVirtualSchedulingGCRA:\n    \"\"\"Virtual Scheduling Generic Cell Rate Algorithm Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the GCR algorithm with the max capacity and time period in seconds\n        max_concurrent: Maximum number of concurrent requests allowed to acquire capacity\n\n    Note:\n        This implementation is asynchronous and supports bursts up to the capacity within the specified time period\n\n    References:\n        https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None, max_concurrent: int | None = None):\n        # import config and set attributes\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds  # units per second\n        self.T = 1 / self.leak_rate  # time to leak one unit\n\n        # burst rate, but can't do this if the amount is variable\n        # self.tau = self.T * self.burst\n\n        # theoretical arrival time (TAT)\n        self._tat: float | None = None\n\n        self.max_concurrent = max_concurrent\n        self._lock = asyncio.Lock()\n\n    async def _acquire_logic(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire resources, blocking if necessary to conform to the rate limit\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Notes:\n            Adding a lock here ensures that the acquire logic is atomic, but it also means that the\n                requests are going to be done in the order they were received  i.e. not out-of-order like\n                most async programs.\n            The benefit is that with multiple concurrent requests, we can ensure that the bucket level\n                is updated correctly and that we don't have multiple requests trying to update the bucket level\n                at the same time, which could lead to an inconsistent state i.e. a race condition.\n        \"\"\"\n        async with self._lock:  # ensure atomicity given we can have multiple concurrent requests\n            t_a = time.monotonic()\n            if self._tat is None:\n                # first cell\n                self._tat = t_a\n\n            # note: we can also make `self.capacity - amount` as class param = burst i.e. independent of capacity\n            tau = self.T * (self.capacity - amount)\n            if t_a &lt; self._tat - tau:\n                delay = (self._tat - tau) - t_a\n                await asyncio.sleep(delay)\n\n            self._tat = max(t_a, self._tat) + amount * self.T\n\n    async def _semaphore_acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire capacity using a semaphore to limit concurrency.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n        \"\"\"\n        semaphore = asyncio.Semaphore(self.max_concurrent) if self.max_concurrent else nullcontext()\n        async with semaphore:\n            await self._acquire_logic(amount)\n\n    async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n        \"\"\"Acquire capacity, waiting asynchronously until allowed.\n\n        Supports timeout and cancellation.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n\n        Raises:\n            TimeoutError: If the acquire operation times out after the specified timeout period\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        if timeout is not None:\n            try:\n                await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n            except TimeoutError as error:\n                raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n        else:\n            await self._semaphore_acquire(amount)\n\n    async def __aenter__(self) -&gt; AsyncVirtualSchedulingGCRA:\n        \"\"\"Enter the context manager, acquiring resources if necessary\n\n        Returns:\n            An instance of the VirtualSchedulingGCRA class\n        \"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\n\n        Args:\n            exc_type: The type of the exception raised\n            exc_val: The value of the exception raised\n            exc_tb: The traceback object\n        \"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncVirtualSchedulingGCRA.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> <p>Returns:</p> Type Description <code>AsyncVirtualSchedulingGCRA</code> <p>An instance of the VirtualSchedulingGCRA class</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncVirtualSchedulingGCRA:\n    \"\"\"Enter the context manager, acquiring resources if necessary\n\n    Returns:\n        An instance of the VirtualSchedulingGCRA class\n    \"\"\"\n    await self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncVirtualSchedulingGCRA.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException]</code> <p>The type of the exception raised</p> required <code>exc_val</code> <code>BaseException</code> <p>The value of the exception raised</p> required <code>exc_tb</code> <code>TracebackType</code> <p>The traceback object</p> required Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\n\n    Args:\n        exc_type: The type of the exception raised\n        exc_val: The value of the exception raised\n        exc_tb: The traceback object\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.AsyncVirtualSchedulingGCRA.acquire","title":"<code>acquire(amount=1, timeout=None)</code>  <code>async</code>","text":"<p>Acquire capacity, waiting asynchronously until allowed.</p> <p>Supports timeout and cancellation.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>Optional timeout in seconds for the acquire operation</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the acquire operation times out after the specified timeout period</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n    \"\"\"Acquire capacity, waiting asynchronously until allowed.\n\n    Supports timeout and cancellation.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n        timeout: Optional timeout in seconds for the acquire operation\n\n    Raises:\n        TimeoutError: If the acquire operation times out after the specified timeout period\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    if timeout is not None:\n        try:\n            await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n        except TimeoutError as error:\n            raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n    else:\n        await self._semaphore_acquire(amount)\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncLeakyBucketGCRA","title":"<code>SyncLeakyBucketGCRA</code>","text":"<p>Continuous-state Leaky Bucket Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the GCR algorithm with the max capacity and time period in seconds</p> required Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> References <p>https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>class SyncLeakyBucketGCRA:\n    \"\"\"Continuous-state Leaky Bucket Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the GCR algorithm with the max capacity and time period in seconds\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n\n    References:\n        https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None):\n        # import config and set attributes\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds  # units per second\n        self.T = 1 / self.leak_rate  # time to leak one unit\n\n        # burst rate, but can't do this if the amount is variable\n        # self.tau = self.T * self.burst\n\n        self._bucket_level = 0.0  # current volume in the bucket\n        self._last_leak: float | None = None  # same as last conforming time or LCT\n\n    def acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire resources, blocking if necessary to conform to the rate limit\n\n        Args:\n            amount: The amount of resources to acquire (default is 1)\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        t_a = time.monotonic()\n        if self._last_leak is None:\n            # first cell\n            self._bucket_level = 0\n            self._last_leak = t_a\n\n        elapsed = t_a - self._last_leak\n        self._bucket_level = self._bucket_level - elapsed\n\n        # note: we can also make `self.capacity - amount` as class param = burst i.e. independent of capacity\n        tau = self.T * (self.capacity - amount)\n        if self._bucket_level &gt; tau:\n            delay = self._bucket_level - tau\n            time.sleep(delay)\n\n            self._bucket_level = self._bucket_level - delay\n            t_a += delay\n\n        self._bucket_level = max(0.0, self._bucket_level) + amount * self.T\n        self._last_leak = t_a\n\n    def __enter__(self) -&gt; SyncLeakyBucketGCRA:\n        \"\"\"Enter the context manager, acquiring resources if necessary\n\n        Returns:\n            An instance of the LeakyBucketGCRA class\n        \"\"\"\n        self.acquire()\n        return self\n\n    def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\n\n        Args:\n            exc_type: The type of the exception raised\n            exc_val: The value of the exception raised\n            exc_tb: The traceback object\n        \"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncLeakyBucketGCRA.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> <p>Returns:</p> Type Description <code>SyncLeakyBucketGCRA</code> <p>An instance of the LeakyBucketGCRA class</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>def __enter__(self) -&gt; SyncLeakyBucketGCRA:\n    \"\"\"Enter the context manager, acquiring resources if necessary\n\n    Returns:\n        An instance of the LeakyBucketGCRA class\n    \"\"\"\n    self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncLeakyBucketGCRA.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException]</code> <p>The type of the exception raised</p> required <code>exc_val</code> <code>BaseException</code> <p>The value of the exception raised</p> required <code>exc_tb</code> <code>TracebackType</code> <p>The traceback object</p> required Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\n\n    Args:\n        exc_type: The type of the exception raised\n        exc_val: The value of the exception raised\n        exc_tb: The traceback object\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncLeakyBucketGCRA.acquire","title":"<code>acquire(amount=1)</code>","text":"<p>Acquire resources, blocking if necessary to conform to the rate limit</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of resources to acquire (default is 1)</p> <code>1</code> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>def acquire(self, amount: float = 1) -&gt; None:\n    \"\"\"Acquire resources, blocking if necessary to conform to the rate limit\n\n    Args:\n        amount: The amount of resources to acquire (default is 1)\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    t_a = time.monotonic()\n    if self._last_leak is None:\n        # first cell\n        self._bucket_level = 0\n        self._last_leak = t_a\n\n    elapsed = t_a - self._last_leak\n    self._bucket_level = self._bucket_level - elapsed\n\n    # note: we can also make `self.capacity - amount` as class param = burst i.e. independent of capacity\n    tau = self.T * (self.capacity - amount)\n    if self._bucket_level &gt; tau:\n        delay = self._bucket_level - tau\n        time.sleep(delay)\n\n        self._bucket_level = self._bucket_level - delay\n        t_a += delay\n\n    self._bucket_level = max(0.0, self._bucket_level) + amount * self.T\n    self._last_leak = t_a\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncVirtualSchedulingGCRA","title":"<code>SyncVirtualSchedulingGCRA</code>","text":"<p>Virtual Scheduling Generic Cell Rate Algorithm Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the GCR algorithm with the max capacity and time period in seconds</p> required Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> References <p>https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>class SyncVirtualSchedulingGCRA:\n    \"\"\"Virtual Scheduling Generic Cell Rate Algorithm Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the GCR algorithm with the max capacity and time period in seconds\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n\n    References:\n        https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None):\n        # import config and set attributes\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds  # units per second\n        self.T = 1 / self.leak_rate  # time to leak one unit\n\n        # burst rate, but can't do this if the amount is variable\n        # self.tau = self.T * self.burst\n\n        # theoretical arrival time (TAT)\n        self._tat: float | None = None\n\n    def acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire resources, blocking if necessary to conform to the rate limit\n\n        Args:\n            amount: The amount of resources to acquire (default is 1)\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        t_a = time.monotonic()\n        if self._tat is None:\n            # first cell\n            self._tat = t_a\n\n        # note: we can also make `self.capacity - amount` as class param = burst i.e. independent of capacity\n        tau = self.T * (self.capacity - amount)\n        if t_a &lt; self._tat - tau:\n            delay = (self._tat - tau) - t_a\n            time.sleep(delay)\n\n        self._tat = max(t_a, self._tat) + amount * self.T\n\n    def __enter__(self) -&gt; SyncVirtualSchedulingGCRA:\n        \"\"\"Enter the context manager, acquiring resources if necessary\n\n        Returns:\n            An instance of the VirtualSchedulingGCRA class\n        \"\"\"\n        self.acquire()\n        return self\n\n    def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\n\n        Args:\n            exc_type: The type of the exception raised\n            exc_val: The value of the exception raised\n            exc_tb: The traceback object\n        \"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncVirtualSchedulingGCRA.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> <p>Returns:</p> Type Description <code>SyncVirtualSchedulingGCRA</code> <p>An instance of the VirtualSchedulingGCRA class</p> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>def __enter__(self) -&gt; SyncVirtualSchedulingGCRA:\n    \"\"\"Enter the context manager, acquiring resources if necessary\n\n    Returns:\n        An instance of the VirtualSchedulingGCRA class\n    \"\"\"\n    self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncVirtualSchedulingGCRA.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[BaseException]</code> <p>The type of the exception raised</p> required <code>exc_val</code> <code>BaseException</code> <p>The value of the exception raised</p> required <code>exc_tb</code> <code>TracebackType</code> <p>The traceback object</p> required Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\n\n    Args:\n        exc_type: The type of the exception raised\n        exc_val: The value of the exception raised\n        exc_tb: The traceback object\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/generic_cell_rate/core/#limitor.generic_cell_rate.core.SyncVirtualSchedulingGCRA.acquire","title":"<code>acquire(amount=1)</code>","text":"<p>Acquire resources, blocking if necessary to conform to the rate limit</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of resources to acquire (default is 1)</p> <code>1</code> Source code in <code>limitor/generic_cell_rate/core.py</code> <pre><code>def acquire(self, amount: float = 1) -&gt; None:\n    \"\"\"Acquire resources, blocking if necessary to conform to the rate limit\n\n    Args:\n        amount: The amount of resources to acquire (default is 1)\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    t_a = time.monotonic()\n    if self._tat is None:\n        # first cell\n        self._tat = t_a\n\n    # note: we can also make `self.capacity - amount` as class param = burst i.e. independent of capacity\n    tau = self.T * (self.capacity - amount)\n    if t_a &lt; self._tat - tau:\n        delay = (self._tat - tau) - t_a\n        time.sleep(delay)\n\n    self._tat = max(t_a, self._tat) + amount * self.T\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/","title":"limitor.leaky_bucket","text":"<p>Leaky Bucket Rate Limiter</p>"},{"location":"reference/limitor/leaky_bucket/core/","title":"limitor.leaky_bucket.core","text":"<p>Leaky Bucket Rate Limiter Implementation</p>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.AsyncLeakyBucket","title":"<code>AsyncLeakyBucket</code>","text":"<p>Asynchronous Leaky Bucket Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the leaky bucket with the max capacity and time period in seconds</p> <code>None</code> <code>max_concurrent</code> <code>int | None</code> <p>Maximum number of concurrent requests allowed to acquire capacity</p> <code>None</code> Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>class AsyncLeakyBucket:\n    \"\"\"Asynchronous Leaky Bucket Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the leaky bucket with the max capacity and time period in seconds\n        max_concurrent: Maximum number of concurrent requests allowed to acquire capacity\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None = None, max_concurrent: int | None = None):\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds\n        self._bucket_level = 0.0\n        self._last_leak = time.monotonic()\n\n        self.max_concurrent = max_concurrent\n        self._lock = asyncio.Lock()\n\n    def _leak(self) -&gt; None:\n        \"\"\"Leak the bucket based on the elapsed time since the last leak\"\"\"\n        now = time.monotonic()\n        elapsed = now - self._last_leak\n        self._bucket_level = max(0.0, self._bucket_level - elapsed * self.leak_rate)\n        self._last_leak = now\n\n    def capacity_info(self, amount: float = 1) -&gt; Capacity:\n        \"\"\"Get the current capacity information of the leaky bucket\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Returns:\n            A named tuple indicating if the bucket has enough capacity and how much more is needed\n        \"\"\"\n        self._leak()\n        needed = self._bucket_level + amount - self.capacity\n        return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n\n    async def _acquire_logic(self, amount: float = 1) -&gt; None:\n        \"\"\"Core logic for acquiring capacity from the leaky bucket.\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Notes:\n            Adding a lock here ensures that the acquire logic is atomic, but it also means that the\n                requests are going to be done in the order they were received  i.e. not out-of-order like\n                most async programs.\n            The benefit is that with multiple concurrent requests, we can ensure that the bucket level\n                is updated correctly and that we don't have multiple requests trying to update the bucket level\n                at the same time, which could lead to an inconsistent state i.e. a race condition.\n        \"\"\"\n        async with self._lock:  # ensures atomicity given we can have multiple concurrent requests\n            capacity_info = self.capacity_info(amount=amount)\n            while not capacity_info.has_capacity:\n                needed = capacity_info.needed_capacity\n                # amount we need to wait to leak (either part or the entire capacity)\n                # needed is guaranteed to be positive here, so we can use it directly\n                wait_time = needed / self.leak_rate\n                if wait_time &gt; 0:\n                    await asyncio.sleep(wait_time)\n\n                capacity_info = self.capacity_info(amount=amount)\n\n            self._bucket_level += amount\n\n    async def _semaphore_acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire capacity using a semaphore to limit concurrency.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n        \"\"\"\n        semaphore = asyncio.Semaphore(self.max_concurrent) if self.max_concurrent else nullcontext()\n        async with semaphore:\n            await self._acquire_logic(amount)\n\n    async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n        \"\"\"Acquire capacity from the leaky bucket, waiting asynchronously until allowed.\n\n        Supports timeout and cancellation.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n\n        Raises:\n            TimeoutError: If the acquire operation times out after the specified timeout period\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        if timeout is not None:\n            try:\n                await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n            except TimeoutError as error:\n                raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n        else:\n            await self._semaphore_acquire(amount)\n\n    async def __aenter__(self) -&gt; AsyncLeakyBucket:\n        \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.AsyncLeakyBucket.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncLeakyBucket:\n    \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n    await self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.AsyncLeakyBucket.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.AsyncLeakyBucket.acquire","title":"<code>acquire(amount=1, timeout=None)</code>  <code>async</code>","text":"<p>Acquire capacity from the leaky bucket, waiting asynchronously until allowed.</p> <p>Supports timeout and cancellation.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>Optional timeout in seconds for the acquire operation</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the acquire operation times out after the specified timeout period</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n    \"\"\"Acquire capacity from the leaky bucket, waiting asynchronously until allowed.\n\n    Supports timeout and cancellation.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n        timeout: Optional timeout in seconds for the acquire operation\n\n    Raises:\n        TimeoutError: If the acquire operation times out after the specified timeout period\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    if timeout is not None:\n        try:\n            await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n        except TimeoutError as error:\n            raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n    else:\n        await self._semaphore_acquire(amount)\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.AsyncLeakyBucket.capacity_info","title":"<code>capacity_info(amount=1)</code>","text":"<p>Get the current capacity information of the leaky bucket</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to check for, defaults to 1</p> <code>1</code> <p>Returns:</p> Type Description <code>Capacity</code> <p>A named tuple indicating if the bucket has enough capacity and how much more is needed</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>def capacity_info(self, amount: float = 1) -&gt; Capacity:\n    \"\"\"Get the current capacity information of the leaky bucket\n\n    Args:\n        amount: The amount of capacity to check for, defaults to 1\n\n    Returns:\n        A named tuple indicating if the bucket has enough capacity and how much more is needed\n    \"\"\"\n    self._leak()\n    needed = self._bucket_level + amount - self.capacity\n    return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.SyncLeakyBucket","title":"<code>SyncLeakyBucket</code>","text":"<p>Leaky Bucket Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the leaky bucket with the max capacity and time period in seconds</p> required Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>class SyncLeakyBucket:\n    \"\"\"Leaky Bucket Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the leaky bucket with the max capacity and time period in seconds\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None):\n        # import config and set attributes\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.leak_rate = self.capacity / self.seconds  # units per second\n\n        self._bucket_level = 0.0  # current volume in the bucket\n        self._last_leak = time.monotonic()  # last leak time\n\n    def _leak(self) -&gt; None:\n        \"\"\"Leak the bucket based on the elapsed time since the last leak\"\"\"\n        now = time.monotonic()\n        elapsed = now - self._last_leak\n        self._bucket_level = max(0.0, self._bucket_level - elapsed * self.leak_rate)\n        self._last_leak = now\n\n    def capacity_info(self, amount: float = 1) -&gt; Capacity:\n        \"\"\"Get the current capacity information of the leaky bucket\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Returns:\n            A named tuple indicating if the bucket has enough capacity and how much more is needed\n        \"\"\"\n        self._leak()\n        needed = self._bucket_level + amount - self.capacity\n        return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n\n    def acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire capacity from the leaky bucket, blocking until enough capacity is available.\n\n        This method will block and sleep until the requested amount can be acquired\n        without exceeding the bucket's capacity, simulating rate limiting.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n\n        Notes:\n            The while loop is just to make sure nothing funny happens while waiting\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        capacity_info = self.capacity_info(amount=amount)\n        while not capacity_info.has_capacity:\n            needed = capacity_info.needed_capacity\n            # amount we need to wait to leak (either part or the entire capacity)\n            # needed is guaranteed to be positive here, so we can use it directly\n            wait_time = needed / self.leak_rate\n            if wait_time &gt; 0:\n                time.sleep(wait_time)\n\n            capacity_info = self.capacity_info(amount=amount)\n\n        self._bucket_level += amount\n\n    def __enter__(self) -&gt; SyncLeakyBucket:\n        \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n        self.acquire()\n        return self\n\n    def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.SyncLeakyBucket.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>def __enter__(self) -&gt; SyncLeakyBucket:\n    \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n    self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.SyncLeakyBucket.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.SyncLeakyBucket.acquire","title":"<code>acquire(amount=1)</code>","text":"<p>Acquire capacity from the leaky bucket, blocking until enough capacity is available.</p> <p>This method will block and sleep until the requested amount can be acquired without exceeding the bucket's capacity, simulating rate limiting.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> Notes <p>The while loop is just to make sure nothing funny happens while waiting</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>def acquire(self, amount: float = 1) -&gt; None:\n    \"\"\"Acquire capacity from the leaky bucket, blocking until enough capacity is available.\n\n    This method will block and sleep until the requested amount can be acquired\n    without exceeding the bucket's capacity, simulating rate limiting.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n\n    Notes:\n        The while loop is just to make sure nothing funny happens while waiting\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    capacity_info = self.capacity_info(amount=amount)\n    while not capacity_info.has_capacity:\n        needed = capacity_info.needed_capacity\n        # amount we need to wait to leak (either part or the entire capacity)\n        # needed is guaranteed to be positive here, so we can use it directly\n        wait_time = needed / self.leak_rate\n        if wait_time &gt; 0:\n            time.sleep(wait_time)\n\n        capacity_info = self.capacity_info(amount=amount)\n\n    self._bucket_level += amount\n</code></pre>"},{"location":"reference/limitor/leaky_bucket/core/#limitor.leaky_bucket.core.SyncLeakyBucket.capacity_info","title":"<code>capacity_info(amount=1)</code>","text":"<p>Get the current capacity information of the leaky bucket</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to check for, defaults to 1</p> <code>1</code> <p>Returns:</p> Type Description <code>Capacity</code> <p>A named tuple indicating if the bucket has enough capacity and how much more is needed</p> Source code in <code>limitor/leaky_bucket/core.py</code> <pre><code>def capacity_info(self, amount: float = 1) -&gt; Capacity:\n    \"\"\"Get the current capacity information of the leaky bucket\n\n    Args:\n        amount: The amount of capacity to check for, defaults to 1\n\n    Returns:\n        A named tuple indicating if the bucket has enough capacity and how much more is needed\n    \"\"\"\n    self._leak()\n    needed = self._bucket_level + amount - self.capacity\n    return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n</code></pre>"},{"location":"reference/limitor/token_bucket/","title":"limitor.token_bucket","text":"<p>Token Bucket Rate Limiter</p>"},{"location":"reference/limitor/token_bucket/core/","title":"limitor.token_bucket.core","text":"<p>Token Bucket Rate Limiter Implementation</p>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.AsyncTokenBucket","title":"<code>AsyncTokenBucket</code>","text":"<p>Asynchronous Leaky Bucket Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the token bucket with the max capacity and time period in seconds</p> <code>None</code> <code>max_concurrent</code> <code>int | None</code> <p>Maximum number of concurrent requests allowed to acquire capacity</p> <code>None</code> Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>class AsyncTokenBucket:\n    \"\"\"Asynchronous Leaky Bucket Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the token bucket with the max capacity and time period in seconds\n        max_concurrent: Maximum number of concurrent requests allowed to acquire capacity\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None = None, max_concurrent: int | None = None):\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.fill_rate = self.capacity / self.seconds\n\n        self._bucket_level = self.capacity\n        self._last_fill = time.monotonic()\n\n        self.max_concurrent = max_concurrent\n        self._lock = asyncio.Lock()\n\n    def _fill(self) -&gt; None:\n        \"\"\"Fill the bucket based on the elapsed time since the last fill\"\"\"\n        now = time.monotonic()\n        elapsed = now - self._last_fill\n        self._bucket_level = min(self.capacity, self._bucket_level + elapsed * self.fill_rate)\n        self._last_fill = now\n\n    def capacity_info(self, amount: float = 1) -&gt; Capacity:\n        \"\"\"Get the current capacity information of the token bucket\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Returns:\n            A named tuple indicating if the bucket has enough capacity and how much more is needed\n        \"\"\"\n        self._fill()\n        # we need at least `amount` tokens to proceed\n        needed = amount - self._bucket_level\n        return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n\n    async def _acquire_logic(self, amount: float = 1) -&gt; None:\n        \"\"\"Core logic for acquiring capacity from the token bucket.\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Notes:\n            Adding a lock here ensures that the acquire logic is atomic, but it also means that the\n                requests are going to be done in the order they were received  i.e. not out-of-order like\n                most async programs.\n            The benefit is that with multiple concurrent requests, we can ensure that the bucket level\n                is updated correctly and that we don't have multiple requests trying to update the bucket level\n                at the same time, which could lead to an inconsistent state i.e. a race condition.\n        \"\"\"\n        async with self._lock:  # ensures atomicity given we can have multiple concurrent requests\n            capacity_info = self.capacity_info(amount=amount)\n            while not capacity_info.has_capacity:\n                needed = capacity_info.needed_capacity\n                # amount we need to wait to leak (either part or the entire capacity)\n                # needed is guaranteed to be positive here, so we can use it directly\n                wait_time = needed / self.fill_rate\n                if wait_time &gt; 0:\n                    await asyncio.sleep(wait_time)\n\n                capacity_info = self.capacity_info(amount=amount)\n\n            self._bucket_level -= amount\n\n    async def _semaphore_acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire capacity using a semaphore to limit concurrency.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n        \"\"\"\n        semaphore = asyncio.Semaphore(self.max_concurrent) if self.max_concurrent else nullcontext()\n        async with semaphore:\n            await self._acquire_logic(amount)\n\n    async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n        \"\"\"Acquire capacity from the token bucket, waiting asynchronously until allowed.\n\n        Supports timeouts and cancellations.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n            timeout: Optional timeout in seconds for the acquire operation\n\n        Raises:\n            TimeoutError: If the acquire operation times out after the specified timeout period\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        if timeout is not None:\n            try:\n                await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n            except TimeoutError as error:\n                raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n        else:\n            await self._semaphore_acquire(amount)\n\n    async def __aenter__(self) -&gt; AsyncTokenBucket:\n        \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n        await self.acquire()\n        return self\n\n    async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.AsyncTokenBucket.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>async def __aenter__(self) -&gt; AsyncTokenBucket:\n    \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n    await self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.AsyncTokenBucket.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>async def __aexit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.AsyncTokenBucket.acquire","title":"<code>acquire(amount=1, timeout=None)</code>  <code>async</code>","text":"<p>Acquire capacity from the token bucket, waiting asynchronously until allowed.</p> <p>Supports timeouts and cancellations.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>Optional timeout in seconds for the acquire operation</p> <code>None</code> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the acquire operation times out after the specified timeout period</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>async def acquire(self, amount: float = 1, timeout: float | None = None) -&gt; None:\n    \"\"\"Acquire capacity from the token bucket, waiting asynchronously until allowed.\n\n    Supports timeouts and cancellations.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n        timeout: Optional timeout in seconds for the acquire operation\n\n    Raises:\n        TimeoutError: If the acquire operation times out after the specified timeout period\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    if timeout is not None:\n        try:\n            await asyncio.wait_for(self._semaphore_acquire(amount), timeout=timeout)\n        except TimeoutError as error:\n            raise TimeoutError(f\"Acquire timed out after {timeout} seconds for amount={amount}\") from error\n    else:\n        await self._semaphore_acquire(amount)\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.AsyncTokenBucket.capacity_info","title":"<code>capacity_info(amount=1)</code>","text":"<p>Get the current capacity information of the token bucket</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to check for, defaults to 1</p> <code>1</code> <p>Returns:</p> Type Description <code>Capacity</code> <p>A named tuple indicating if the bucket has enough capacity and how much more is needed</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>def capacity_info(self, amount: float = 1) -&gt; Capacity:\n    \"\"\"Get the current capacity information of the token bucket\n\n    Args:\n        amount: The amount of capacity to check for, defaults to 1\n\n    Returns:\n        A named tuple indicating if the bucket has enough capacity and how much more is needed\n    \"\"\"\n    self._fill()\n    # we need at least `amount` tokens to proceed\n    needed = amount - self._bucket_level\n    return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.SyncTokenBucket","title":"<code>SyncTokenBucket</code>","text":"<p>Token Bucket Rate Limiter</p> <p>Parameters:</p> Name Type Description Default <code>bucket_config</code> <code>BucketConfig | None</code> <p>Configuration for the token bucket with the max capacity and time period in seconds</p> required Note <p>This implementation is synchronous and supports bursts up to the capacity within the specified time period</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>class SyncTokenBucket:\n    \"\"\"Token Bucket Rate Limiter\n\n    Args:\n        bucket_config: Configuration for the token bucket with the max capacity and time period in seconds\n\n    Note:\n        This implementation is synchronous and supports bursts up to the capacity within the specified time period\n    \"\"\"\n\n    def __init__(self, bucket_config: BucketConfig | None):\n        # import config and set attributes\n        config = bucket_config or BucketConfig()\n        self.capacity = config.capacity\n        self.seconds = config.seconds\n\n        self.fill_rate = self.capacity / self.seconds  # units per second\n\n        self._bucket_level = self.capacity  # current volume of tokens in the bucket\n        self._last_fill = time.monotonic()  # last refill time\n\n    def _fill(self) -&gt; None:\n        \"\"\"Fill the bucket based on the elapsed time since the last fill\"\"\"\n        now = time.monotonic()\n        elapsed = now - self._last_fill\n        self._bucket_level = min(self.capacity, self._bucket_level + elapsed * self.fill_rate)\n        self._last_fill = now\n\n    def capacity_info(self, amount: float = 1) -&gt; Capacity:\n        \"\"\"Get the current capacity information of the token bucket\n\n        Args:\n            amount: The amount of capacity to check for, defaults to 1\n\n        Returns:\n            A named tuple indicating if the bucket has enough capacity and how much more is needed\n        \"\"\"\n        self._fill()\n        # we need at least `amount` tokens to proceed\n        needed = amount - self._bucket_level\n        return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n\n    def acquire(self, amount: float = 1) -&gt; None:\n        \"\"\"Acquire capacity from the token bucket, blocking until enough capacity is available.\n\n        This method will block and sleep until the requested amount can be acquired\n        without exceeding the bucket's capacity, simulating rate limiting.\n\n        Args:\n            amount: The amount of capacity to acquire, defaults to 1\n\n        Notes:\n            The while loop is just to make sure nothing funny happens while waiting\n        \"\"\"\n        validate_amount(self, amount=amount)\n\n        capacity_info = self.capacity_info(amount=amount)\n        while not capacity_info.has_capacity:\n            needed = capacity_info.needed_capacity\n            # amount we need to wait to leak\n            # needed is guaranteed to be positive here, so we can use it directly\n            wait_time = needed / self.fill_rate\n            if wait_time &gt; 0:\n                time.sleep(wait_time)\n\n            capacity_info = self.capacity_info(amount=amount)\n\n        self._bucket_level -= amount\n\n    def __enter__(self) -&gt; SyncTokenBucket:\n        \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n        self.acquire()\n        return self\n\n    def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n        \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n        return None\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.SyncTokenBucket.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context manager, acquiring resources if necessary</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>def __enter__(self) -&gt; SyncTokenBucket:\n    \"\"\"Enter the context manager, acquiring resources if necessary\"\"\"\n    self.acquire()\n    return self\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.SyncTokenBucket.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context manager, releasing any resources if necessary</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_val: BaseException, exc_tb: TracebackType) -&gt; None:\n    \"\"\"Exit the context manager, releasing any resources if necessary\"\"\"\n    return None\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.SyncTokenBucket.acquire","title":"<code>acquire(amount=1)</code>","text":"<p>Acquire capacity from the token bucket, blocking until enough capacity is available.</p> <p>This method will block and sleep until the requested amount can be acquired without exceeding the bucket's capacity, simulating rate limiting.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to acquire, defaults to 1</p> <code>1</code> Notes <p>The while loop is just to make sure nothing funny happens while waiting</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>def acquire(self, amount: float = 1) -&gt; None:\n    \"\"\"Acquire capacity from the token bucket, blocking until enough capacity is available.\n\n    This method will block and sleep until the requested amount can be acquired\n    without exceeding the bucket's capacity, simulating rate limiting.\n\n    Args:\n        amount: The amount of capacity to acquire, defaults to 1\n\n    Notes:\n        The while loop is just to make sure nothing funny happens while waiting\n    \"\"\"\n    validate_amount(self, amount=amount)\n\n    capacity_info = self.capacity_info(amount=amount)\n    while not capacity_info.has_capacity:\n        needed = capacity_info.needed_capacity\n        # amount we need to wait to leak\n        # needed is guaranteed to be positive here, so we can use it directly\n        wait_time = needed / self.fill_rate\n        if wait_time &gt; 0:\n            time.sleep(wait_time)\n\n        capacity_info = self.capacity_info(amount=amount)\n\n    self._bucket_level -= amount\n</code></pre>"},{"location":"reference/limitor/token_bucket/core/#limitor.token_bucket.core.SyncTokenBucket.capacity_info","title":"<code>capacity_info(amount=1)</code>","text":"<p>Get the current capacity information of the token bucket</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float</code> <p>The amount of capacity to check for, defaults to 1</p> <code>1</code> <p>Returns:</p> Type Description <code>Capacity</code> <p>A named tuple indicating if the bucket has enough capacity and how much more is needed</p> Source code in <code>limitor/token_bucket/core.py</code> <pre><code>def capacity_info(self, amount: float = 1) -&gt; Capacity:\n    \"\"\"Get the current capacity information of the token bucket\n\n    Args:\n        amount: The amount of capacity to check for, defaults to 1\n\n    Returns:\n        A named tuple indicating if the bucket has enough capacity and how much more is needed\n    \"\"\"\n    self._fill()\n    # we need at least `amount` tokens to proceed\n    needed = amount - self._bucket_level\n    return Capacity(has_capacity=needed &lt;= 0, needed_capacity=needed)\n</code></pre>"},{"location":"reference/limitor/utils/","title":"limitor.utils","text":""},{"location":"reference/limitor/utils/#limitor.utils.ensure_decimal_amount","title":"<code>ensure_decimal_amount(func)</code>","text":"<p>Decorator to ensure that the 'amount' argument is of type Decimal</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The function to decorate</p> required <p>Returns:</p> Type Description <code>Callable[P, R]</code> <p>A decorated function that ensures 'amount' is a Decimal</p> Source code in <code>limitor/utils.py</code> <pre><code>def ensure_decimal_amount[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]:\n    \"\"\"Decorator to ensure that the 'amount' argument is of type Decimal\n\n    Args:\n        func: The function to decorate\n\n    Returns:\n        A decorated function that ensures 'amount' is a Decimal\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:\n        sig = inspect.signature(func)\n        bound = sig.bind(*args, **kwargs)\n        bound.apply_defaults()\n        if \"amount\" in bound.arguments:\n            amt = bound.arguments[\"amount\"]\n            if not isinstance(amt, Decimal):\n                bound.arguments[\"amount\"] = Decimal(amt)\n\n        return func(*bound.args, **bound.kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/limitor/utils/#limitor.utils.validate_amount","title":"<code>validate_amount(rate_limiter, amount)</code>","text":"<p>Validate the requested amount for acquire</p> <p>Parameters:</p> Name Type Description Default <code>rate_limiter</code> <code>HasCapacity</code> <p>the rate limiter i.e. SyncLeakyBucket or AsyncTokenBucket</p> required <code>amount</code> <code>float</code> <p>The amount of capacity to acquire</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested amount exceeds the bucket's capacity or is negative</p> Source code in <code>limitor/utils.py</code> <pre><code>def validate_amount(rate_limiter: HasCapacity, amount: float) -&gt; None:\n    \"\"\"Validate the requested amount for acquire\n\n    Args:\n        rate_limiter: the rate limiter i.e. SyncLeakyBucket or AsyncTokenBucket\n        amount: The amount of capacity to acquire\n\n    Raises:\n        ValueError: If the requested amount exceeds the bucket's capacity or is negative\n    \"\"\"\n    if amount &gt; rate_limiter.capacity:\n        raise ValueError(f\"Cannot acquire more than the bucket's capacity: {rate_limiter.capacity}\")\n\n    if amount &lt; 0:\n        raise ValueError(f\"Cannot acquire less than 0 amount with amount: {amount}\")\n</code></pre>"}]}